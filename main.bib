@inproceedings{bera_pythia_2021,
	address = {Virtual Event Greece},
	title = {Pythia: {A} {Customizable} {Hardware} {Prefetching} {Framework} {Using} {Online} {Reinforcement} {Learning}},
	isbn = {978-1-4503-8557-2},
	shorttitle = {Pythia},
	url = {https://dl.acm.org/doi/10.1145/3466752.3480114},
	doi = {10.1145/3466752.3480114},
	language = {en},
	urldate = {2023-01-24},
	booktitle = {{MICRO}-54: 54th {Annual} {IEEE}/{ACM} {International} {Symposium} on {Microarchitecture}},
	publisher = {ACM},
	author = {Bera, Rahul and Kanellopoulos, Konstantinos and Nori, Anant and Shahroodi, Taha and Subramoney, Sreenivas and Mutlu, Onur},
	month = oct,
	year = {2021},
	keywords = {next},
	pages = {1121--1137},
}

@inproceedings{talati_prodigy_2021,
	address = {Seoul, Korea (South)},
	title = {Prodigy: {Improving} the {Memory} {Latency} of {Data}-{Indirect} {Irregular} {Workloads} {Using} {Hardware}-{Software} {Co}-{Design}},
	isbn = {978-1-66542-235-2},
	shorttitle = {Prodigy},
	url = {https://ieeexplore.ieee.org/document/9407222/},
	doi = {10.1109/HPCA51647.2021.00061},
	urldate = {2022-09-27},
	booktitle = {2021 {IEEE} {International} {Symposium} on {High}-{Performance} {Computer} {Architecture} ({HPCA})},
	publisher = {IEEE},
	author = {Talati, Nishil and May, Kyle and Behroozi, Armand and Yang, Yichen and Kaszyk, Kuba and Vasiladiotis, Christos and Verma, Tarunesh and Li, Lu and Nguyen, Brandon and Sun, Jiawen and Morton, John Magnus and Ahmadi, Agreen and Austin, Todd and O'Boyle, Michael and Mahlke, Scott and Mudge, Trevor and Dreslinski, Ronald},
	month = feb,
	year = {2021},
	keywords = {L1, programmable prefetcher, reactive},
	pages = {654--667},
}

@article{ainsworth_software_2018,
	title = {Software {Prefetching} for {Indirect} {Memory} {Accesses}: {A} {Microarchitectural} {Perspective}},
	volume = {36},
	issn = {0734-2071, 1557-7333},
	shorttitle = {Software {Prefetching} for {Indirect} {Memory} {Accesses}},
	url = {https://dl.acm.org/doi/10.1145/3319393},
	doi = {10.1145/3319393},
	abstract = {Many modern data processing and HPC workloads are heavily memory-latency bound. A tempting proposition to solve this is software prefetching, where special non-blocking loads are used to bring data into the cache hierarchy just before being required. However, these are difficult to insert to effectively improve performance, and techniques for automatic insertion are currently limited.
            This article develops a novel compiler pass to automatically generate software prefetches for indirect memory accesses, a special class of irregular memory accesses often seen in high-performance workloads. We evaluate this across a wide set of systems, all of which gain benefit from the technique. We then evaluate the extent to which good prefetch instructions are architecture dependent and the class of programs that are particularly amenable. Across a set of memory-bound benchmarks, our automated pass achieves average speedups of 1.3× for an Intel Haswell processor, 1.1× for both an ARM Cortex-A57 and Qualcomm Kryo, 1.2× for a Cortex-72 and an Intel Kaby Lake, and 1.35× for an Intel Xeon Phi Knight’s Landing, each of which is an out-of-order core, and performance improvements of 2.1× and 2.7× for the in-order ARM Cortex-A53 and first generation Intel Xeon Phi.},
	language = {en},
	number = {3},
	urldate = {2023-03-10},
	journal = {ACM Transactions on Computer Systems},
	author = {Ainsworth, Sam and Jones, Timothy M.},
	month = aug,
	year = {2018},
	pages = {1--34},
}

@article{manocha_graphattack_2021,
	title = {{GraphAttack}: {Optimizing} {Data} {Supply} for {Graph} {Applications} on {In}-{Order} {Multicore} {Architectures}},
	volume = {18},
	issn = {1544-3566, 1544-3973},
	shorttitle = {{GraphAttack}},
	url = {https://dl.acm.org/doi/10.1145/3469846},
	doi = {10.1145/3469846},
	abstract = {Graph structures are a natural representation of important and pervasive data. While graph applications have significant parallelism, their characteristic pointer indirect loads to neighbor data hinder scalability to large datasets on multicore systems. A scalable and efficient system must tolerate latency while leveraging data parallelism across millions of vertices. Modern Out-of-Order (OoO) cores inherently tolerate a fraction of long latencies, but become clogged when running severely memory-bound applications. Combined with large power/area footprints, this limits their parallel scaling potential and, consequently, the gains that existing software frameworks can achieve. Conversely, accelerator and memory hierarchy designs provide performant hardware specializations, but cannot support diverse application demands.
            To address these shortcomings, we present GraphAttack, a hardware-software data supply approach that accelerates graph applications on in-order multicore architectures. GraphAttack proposes compiler passes to (1) identify idiomatic long-latency loads and (2) slice programs along these loads into data Producer/ Consumer threads to map onto pairs of parallel cores. Each pair shares a communication queue; the Producer asynchronously issues long-latency loads, whose results are buffered in the queue and used by the Consumer. This scheme drastically increases memory-level parallelism (MLP) to mitigate latency bottlenecks. In equal-area comparisons, GraphAttack outperforms OoO cores, do-all parallelism, prefetching, and prior decoupling approaches, achieving a 2.87× speedup and 8.61× gain in energy efficiency across a range of graph applications. These improvements scale; GraphAttack achieves a 3× speedup over 64 parallel cores. Lastly, it has pragmatic design principles; it enhances in-order architectures that are gaining increasing open-source support.},
	language = {en},
	number = {4},
	urldate = {2023-01-25},
	journal = {ACM Transactions on Architecture and Code Optimization},
	author = {Manocha, Aninda and Sorensen, Tyler and Tureci, Esin and Matthews, Opeoluwa and Aragon, Juan L. and Martonosi, Margaret},
	month = dec,
	year = {2021},
	keywords = {not-cache(com queues), not-reactive, run-ahead},
	pages = {1--26},
}

@inproceedings{Nguyen2023,
  doi = {10.1109/hpca56546.2023.10071026},
  url = {https://doi.org/10.1109/hpca56546.2023.10071026},
  year = {2023},
  month = feb,
  publisher = {{IEEE}},
  author = {Quan M. Nguyen and Daniel Sanchez},
  title = {Phloem: Automatic Acceleration of Irregular Applications with Fine-Grain Pipeline Parallelism},
  booktitle = {2023 {IEEE} International Symposium on High-Performance Computer Architecture ({HPCA})}
}

@article{Dijkstra1983,
  doi = {10.1016/0020-0190(83)90092-3},
  url = {https://doi.org/10.1016/0020-0190(83)90092-3},
  year = {1983},
  month = jun,
  publisher = {Elsevier {BV}},
  volume = {16},
  number = {5},
  pages = {217--219},
  author = {Edsger W. Dijkstra and W.H.J. Feijen and A.J.M. van Gasteren},
  title = {Derivation of a termination detection algorithm for distributed computations},
  journal = {Information Processing Letters}
}

@article{cytron_efficiently_1991,
	title = {Efficiently computing static single assignment form and the control dependence graph},
	volume = {13},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/115372.115320},
	doi = {10.1145/115372.115320},
	language = {en},
	number = {4},
	urldate = {2023-02-07},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K. and Wegman, Mark N. and Zadeck, F. Kenneth},
	month = oct,
	year = {1991},
	pages = {451--490},
}
