\documentclass{acaces}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{minted}

\lstdefinestyle{cppcode}{
    language=C++,
    basicstyle=\footnotesize\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{purple},
    frame=none,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt
}

\begin{document}

\title{DPREF: Decoupling using Dead Code Elimination for Prefetching Irregular Memory Accesses}

\author{
Konstantinos~Sotiropoulos\addressnum{1}\comma\extranum{1},
Jonas~Skeppstedt\addressnum{2}\comma\extranum{2},
Angelos~Arelakis\addressnum{3}\comma\extranum{3},
Per~Stenstr\"{o}m\addressnum{1}\comma\extranum{1}
}

\address{1}{
  Chalmers University of Technology
}

\address{2}{
  Lund University
}

\address{3}{
  ZeroPoint Technologies
}

\extra{1}{\{konstantinos.sotirpoulos,per.stenstrom\}@chalmers.se}
\extra{2}{jonas.skeppstedt@cs.lth.se}
\extra{3}{angelos.arelakis@zptcorp.com}

\pagestyle{empty}

\begin{abstract}

  Decoupling refers to the act of slicing a single instruction stream into separate memory accessing and computation streams,
  and arranging them in a dataflow manner.
  As these instruction streams gain a certain level of autonomy, decoupling can serve as a means to achieve accurate and timely prefetching.

  This research aims to advance previous works on compile-time decoupling by proposing a systematic approach to slicing.
  The ultimate goal is to broaden the applicability to a wider range of irregular applications that existing methods struggle to address. \\

\end{abstract}

\keywords{irregular applications; decoupling; slicing; prefetching; DCE}

\section{Introduction}

Irregular memory accesses pose a significant challenge in applications within graph analytics, database management systems, and sparse linear algebra.
These applications experience high execution times due to frequent stalls caused by long latency DRAM accesses.
Prefetching is a latency avoidance technique that aims to bring useful data closer to the processor before it is requested.

A recent wave of proposals aims to provide timely and accurate prefetches for irregular applications that use sparse data structures,
demonstrating very promising results \cite{manocha_graphattack_2021, Nguyen2023}.
Due to the way sparse data structures are represented,
their traversal exhibits a specific type of irregularity, indirection, typically taking the form \mintinline{C}{A[B[C[i]]]}.
The key idea behind these proposals is to decouple such multi-level indirection into distinct pipeline stages, each housing a slice of the application

These proposals represent examples of hardware-software co-design:
the decoupling is enacted by the compiler, and they offer ISA-visible queues for stage-to-stage communication.
These queues benefit from low-latency hardware implementation as inter-stage communication occurs every few cycles.

The primary purpose of this study is to extend these proposals through a more systematic compiler slicing technique, utilizing an established optimization technique called Dead Code Elimination (DCE) \cite{cytron_efficiently_1991}.
This approach aims to handle a wider range of applications, offering more flexibility in the decoupling process.

\section{DCE for Slicing}

With DCE, the compiler partitions an application into redundant and essential code, and then discards the redundant portion.
The algorithm maintains a workset of live instructions.
The workset is initialized with a set of pre-live instructions, such as memory stores, that explicitly modify system state.
Live instructions are iteratively removed from the workset for control- and data-dependency examination,
subsequently adding more instructions based on outcome of this examination.

With an intermediate representation of a program in Static Single-Assingment (SSA) form,
identifying data dependencies is straightforward due to the unambiguous definition of each variable.
Control dependencies, on the other hand, necessitate a post-dominance analysis on the CFG.
A live instruction is deemed control-dependent on a conditional statement
if the basic block containing the live instruction is part of the post-dominance frontier of the basic block that houses the conditional.
In other words, if the live instruction is not always on the path from a conditional to the program's exit, then the conditional should be considered live.

DCE can evolve into a flexible slicing technique through redefining what is considered as a pre-live instruction.
The redundant portion is not discarded; instead, it undergoes a dependency examination, similar to pre-live code, and subsequently forms one of the two slices, the other being the pre-live instructions and their dependencies.
This slicing process can then be systematically and recursively applied.

The identification of pre-live instructions is central to the programmer/compiler interface design,
potentially facilitated by annotations, as discussed in the upcoming section,
and proves critical in kickstarting the slicing process.

\section{DPREF on SpMV}

Figure \ref{fig:spmv} demonstrates the the product y = Ax of a sparse matrix A and a dense vector x (SpMV) where A is stored in Compressed Sparse Row (CSR) format.
Array \mintinline{C++}{Values} stores all non-zero values of the matrix and array \mintinline{C++}{ColIdx} stores the column index of each non-zero value.
The \mintinline{C++}{Offsets} array denotes the start index of each row in the \mintinline{C++}{Values} and \mintinline{C++}{ColIdx} arrays.
For instance, the non-zero values of row \mintinline{C++}{n} in the \mintinline{C++}{Values} arrays start at index \mintinline{C++}{Offsets[n]}
and end just before index \mintinline{C++}{Offsets[n+1]}.

The \mintinline{C++}{pragma} directive in line (1) explicitly denotes this relationship among the arrays.
The compiler leverages this annotation to mark as pre-live the instructions that use \mintinline{C++}{Values} and \mintinline{C++}{X},
while deliberately excluding their indices from the dependency analysis.
This marks the beginning of the first slicing phase.

Figure \ref{fig:firstSlice} is the slice that corresponds to the dead code.
Notice how the queue is used to convey tokens that can represent either data or control flow information.
Figure \ref{fig:secondSlice} is the slice that corresponds to the live code.
Notice how the token popped from the queue is first examined for control flow information.

\begin{figure}[ht]
  \centering
  \input{SpMV.tex}
  \caption{SpMV, before slicing. Shaded in red is exclusively live code, shaded in green is exclusively dead code, and code in yellow is common to both. }
  \label{fig:spmv}
\end{figure}

\begin{figure}[ht]
  \centering

  \begin{subfigure}{1.0\textwidth}
    \centering
    \input{firstSlice.tex}
    \caption{The first slice corresponding to the dead code}
    \label{fig:firstSlice}
  \end{subfigure}

  \begin{subfigure}{1.0\textwidth}
    \centering
    \input{secondSlice.tex}
    \caption{The second slice corresponding to the live code}
    \label{fig:secondSlice}
  \end{subfigure}

\end{figure}

\section{Preliminary Conclusion}

Our work is currently in progress, exploring the viability of our proposed approach through manual application slicing.
Our study extends beyond the SpMV algorithm, including applications like breadth-first search, PageRank, and Hash Join.
Three primary challenges have emerged from our findings thus far.

First, for algorithms that are not as straightforwardly decouplable as SpMV, and which encompass feedback loops, it's essential for the compiler to discern and reason about critical system properties, such as deadlock.
Modeling the system as a Petri net within the compiler might offer a viable solution to this issue.

Second, when a feedback loop exists between the first and final slice, a distributed termination solution is required.
Specifically, the first slice needs to determine when all queues are empty and all slices are inactive so that the termination token can be injected \cite{Dijkstra1983}.

Lastly, the microarchitecture of the processor, apart from facilitating quick push/pop operations, must also handle the overhead associated with checking for control flow tokens.

\section{Acknowledgement}

This work was partially supported by the Wallenberg AI, Autonomous Systems and Software Program (WASP)
funded by the Knut and Alice Wallenberg Foundation.

\bibliography{main}

\end{document}
